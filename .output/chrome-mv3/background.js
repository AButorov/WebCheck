var background=function(){"use strict";var F,P,R,U;function N(o){return o==null||typeof o=="function"?{main:o}:o}var W=Object.prototype.hasOwnProperty;function O(o,e){var n,i;if(o===e)return!0;if(o&&e&&(n=o.constructor)===e.constructor){if(n===Date)return o.getTime()===e.getTime();if(n===RegExp)return o.toString()===e.toString();if(n===Array){if((i=o.length)===e.length)for(;i--&&O(o[i],e[i]););return i===-1}if(!n||typeof o=="object"){i=0;for(n in o)if(W.call(o,n)&&++i&&!W.call(e,n)||!(n in e)||!O(o[n],e[n]))return!1;return Object.keys(e).length===i}}return o!==o&&e!==e}const B=new Error("request for lock canceled");var Y=function(o,e,n,i){function h(l){return l instanceof n?l:new n(function(d){d(l)})}return new(n||(n=Promise))(function(l,d){function g(v){try{I(i.next(v))}catch(b){d(b)}}function p(v){try{I(i.throw(v))}catch(b){d(b)}}function I(v){v.done?l(v.value):h(v.value).then(g,p)}I((i=i.apply(o,e||[])).next())})};class z{constructor(e,n=B){this._value=e,this._cancelError=n,this._queue=[],this._weightedWaiters=[]}acquire(e=1,n=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((i,h)=>{const l={resolve:i,reject:h,weight:e,priority:n},d=C(this._queue,g=>n<=g.priority);d===-1&&e<=this._value?this._dispatchItem(l):this._queue.splice(d+1,0,l)})}runExclusive(e){return Y(this,arguments,void 0,function*(n,i=1,h=0){const[l,d]=yield this.acquire(i,h);try{return yield n(l)}finally{d()}})}waitForUnlock(e=1,n=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,n)?Promise.resolve():new Promise(i=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),G(this._weightedWaiters[e-1],{resolve:i,priority:n})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const n=this._value;this._value-=e.weight,e.resolve([n,this._newReleaser(e.weight)])}_newReleaser(e){let n=!1;return()=>{n||(n=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const n=this._weightedWaiters[e-1];n&&(n.forEach(i=>i.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let n=this._value;n>0;n--){const i=this._weightedWaiters[n-1];if(!i)continue;const h=i.findIndex(l=>l.priority<=e);(h===-1?i:i.splice(0,h)).forEach(l=>l.resolve())}}}_couldLockImmediately(e,n){return(this._queue.length===0||this._queue[0].priority<n)&&e<=this._value}}function G(o,e){const n=C(o,i=>e.priority<=i.priority);o.splice(n+1,0,e)}function C(o,e){for(let n=o.length-1;n>=0;n--)if(e(o[n]))return n;return-1}var H=function(o,e,n,i){function h(l){return l instanceof n?l:new n(function(d){d(l)})}return new(n||(n=Promise))(function(l,d){function g(v){try{I(i.next(v))}catch(b){d(b)}}function p(v){try{I(i.throw(v))}catch(b){d(b)}}function I(v){v.done?l(v.value):h(v.value).then(g,p)}I((i=i.apply(o,e||[])).next())})};class J{constructor(e){this._semaphore=new z(1,e)}acquire(){return H(this,arguments,void 0,function*(e=0){const[,n]=yield this._semaphore.acquire(1,e);return n})}runExclusive(e,n=0){return this._semaphore.runExclusive(()=>e(),1,n)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}const $=((P=(F=globalThis.browser)==null?void 0:F.runtime)==null?void 0:P.id)==null?globalThis.chrome:globalThis.browser,S=X();function X(){const o={local:V("local"),session:V("session"),sync:V("sync"),managed:V("managed")},e=s=>{const t=o[s];if(t==null){const r=Object.keys(o).join(", ");throw Error(`Invalid area "${s}". Options: ${r}`)}return t},n=s=>{const t=s.indexOf(":"),r=s.substring(0,t),a=s.substring(t+1);if(a==null)throw Error(`Storage key should be in the form of "area:key", but received "${s}"`);return{driverArea:r,driverKey:a,driver:e(r)}},i=s=>s+"$",h=(s,t)=>{const r={...s};return Object.entries(t).forEach(([a,c])=>{c==null?delete r[a]:r[a]=c}),r},l=(s,t)=>s??t??null,d=s=>typeof s=="object"&&!Array.isArray(s)?s:{},g=async(s,t,r)=>{const a=await s.getItem(t);return l(a,(r==null?void 0:r.fallback)??(r==null?void 0:r.defaultValue))},p=async(s,t)=>{const r=i(t),a=await s.getItem(r);return d(a)},I=async(s,t,r)=>{await s.setItem(t,r??null)},v=async(s,t,r)=>{const a=i(t),c=d(await s.getItem(a));await s.setItem(a,h(c,r))},b=async(s,t,r)=>{if(await s.removeItem(t),r!=null&&r.removeMeta){const a=i(t);await s.removeItem(a)}},A=async(s,t,r)=>{const a=i(t);if(r==null)await s.removeItem(a);else{const c=d(await s.getItem(a));[r].flat().forEach(u=>delete c[u]),await s.setItem(a,c)}},D=(s,t,r)=>s.watch(t,r);return{getItem:async(s,t)=>{const{driver:r,driverKey:a}=n(s);return await g(r,a,t)},getItems:async s=>{const t=new Map,r=new Map,a=[];s.forEach(u=>{let w,m;typeof u=="string"?w=u:"getValue"in u?(w=u.key,m={fallback:u.fallback}):(w=u.key,m=u.options),a.push(w);const{driverArea:E,driverKey:y}=n(w),_=t.get(E)??[];t.set(E,_.concat(y)),r.set(w,m)});const c=new Map;return await Promise.all(Array.from(t.entries()).map(async([u,w])=>{(await o[u].getItems(w)).forEach(E=>{const y=`${u}:${E.key}`,_=r.get(y),f=l(E.value,(_==null?void 0:_.fallback)??(_==null?void 0:_.defaultValue));c.set(y,f)})})),a.map(u=>({key:u,value:c.get(u)}))},getMeta:async s=>{const{driver:t,driverKey:r}=n(s);return await p(t,r)},getMetas:async s=>{const t=s.map(c=>{const u=typeof c=="string"?c:c.key,{driverArea:w,driverKey:m}=n(u);return{key:u,driverArea:w,driverKey:m,driverMetaKey:i(m)}}),r=t.reduce((c,u)=>{var w;return c[w=u.driverArea]??(c[w]=[]),c[u.driverArea].push(u),c},{}),a={};return await Promise.all(Object.entries(r).map(async([c,u])=>{const w=await $.storage[c].get(u.map(m=>m.driverMetaKey));u.forEach(m=>{a[m.key]=w[m.driverMetaKey]??{}})})),t.map(c=>({key:c.key,meta:a[c.key]}))},setItem:async(s,t)=>{const{driver:r,driverKey:a}=n(s);await I(r,a,t)},setItems:async s=>{const t={};s.forEach(r=>{const{driverArea:a,driverKey:c}=n("key"in r?r.key:r.item.key);t[a]??(t[a]=[]),t[a].push({key:c,value:r.value})}),await Promise.all(Object.entries(t).map(async([r,a])=>{await e(r).setItems(a)}))},setMeta:async(s,t)=>{const{driver:r,driverKey:a}=n(s);await v(r,a,t)},setMetas:async s=>{const t={};s.forEach(r=>{const{driverArea:a,driverKey:c}=n("key"in r?r.key:r.item.key);t[a]??(t[a]=[]),t[a].push({key:c,properties:r.meta})}),await Promise.all(Object.entries(t).map(async([r,a])=>{const c=e(r),u=a.map(({key:y})=>i(y));console.log(r,u);const w=await c.getItems(u),m=Object.fromEntries(w.map(({key:y,value:_})=>[y,d(_)])),E=a.map(({key:y,properties:_})=>{const f=i(y);return{key:f,value:h(m[f]??{},_)}});await c.setItems(E)}))},removeItem:async(s,t)=>{const{driver:r,driverKey:a}=n(s);await b(r,a,t)},removeItems:async s=>{const t={};s.forEach(r=>{let a,c;typeof r=="string"?a=r:"getValue"in r?a=r.key:"item"in r?(a=r.item.key,c=r.options):(a=r.key,c=r.options);const{driverArea:u,driverKey:w}=n(a);t[u]??(t[u]=[]),t[u].push(w),c!=null&&c.removeMeta&&t[u].push(i(w))}),await Promise.all(Object.entries(t).map(async([r,a])=>{await e(r).removeItems(a)}))},clear:async s=>{await e(s).clear()},removeMeta:async(s,t)=>{const{driver:r,driverKey:a}=n(s);await A(r,a,t)},snapshot:async(s,t)=>{var c;const a=await e(s).snapshot();return(c=t==null?void 0:t.excludeKeys)==null||c.forEach(u=>{delete a[u],delete a[i(u)]}),a},restoreSnapshot:async(s,t)=>{await e(s).restoreSnapshot(t)},watch:(s,t)=>{const{driver:r,driverKey:a}=n(s);return D(r,a,t)},unwatch(){Object.values(o).forEach(s=>{s.unwatch()})},defineItem:(s,t)=>{const{driver:r,driverKey:a}=n(s),{version:c=1,migrations:u={}}=t??{};if(c<1)throw Error("Storage item version cannot be less than 1. Initial versions should be set to 1, not 0.");const w=async()=>{var Q;const f=i(a),[{value:M},{value:x}]=await r.getItems([a,f]);if(M==null)return;const k=(x==null?void 0:x.v)??1;if(k>c)throw Error(`Version downgrade detected (v${k} -> v${c}) for "${s}"`);if(k===c)return;console.debug(`[@wxt-dev/storage] Running storage migration for ${s}: v${k} -> v${c}`);const re=Array.from({length:c-k},(L,T)=>k+T+1);let K=M;for(const L of re)try{K=await((Q=u==null?void 0:u[L])==null?void 0:Q.call(u,K))??K}catch(T){throw new Z(s,L,{cause:T})}await r.setItems([{key:a,value:K},{key:f,value:{...x,v:c}}]),console.debug(`[@wxt-dev/storage] Storage migration completed for ${s} v${c}`,{migratedValue:K})},m=(t==null?void 0:t.migrations)==null?Promise.resolve():w().catch(f=>{console.error(`[@wxt-dev/storage] Migration failed for ${s}`,f)}),E=new J,y=()=>(t==null?void 0:t.fallback)??(t==null?void 0:t.defaultValue)??null,_=()=>E.runExclusive(async()=>{const f=await r.getItem(a);if(f!=null||(t==null?void 0:t.init)==null)return f;const M=await t.init();return await r.setItem(a,M),M});return m.then(_),{key:s,get defaultValue(){return y()},get fallback(){return y()},getValue:async()=>(await m,t!=null&&t.init?await _():await g(r,a,t)),getMeta:async()=>(await m,await p(r,a)),setValue:async f=>(await m,await I(r,a,f)),setMeta:async f=>(await m,await v(r,a,f)),removeValue:async f=>(await m,await b(r,a,f)),removeMeta:async f=>(await m,await A(r,a,f)),watch:f=>D(r,a,(M,x)=>f(M??y(),x??y())),migrate:w}}}}function V(o){const e=()=>{if($.runtime==null)throw Error(["'wxt/storage' must be loaded in a web extension environment",`
 - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371`,` - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/go-further/testing.html
`].join(`
`));if($.storage==null)throw Error("You must add the 'storage' permission to your manifest to use 'wxt/storage'");const i=$.storage[o];if(i==null)throw Error(`"browser.storage.${o}" is undefined`);return i},n=new Set;return{getItem:async i=>(await e().get(i))[i],getItems:async i=>{const h=await e().get(i);return i.map(l=>({key:l,value:h[l]??null}))},setItem:async(i,h)=>{h==null?await e().remove(i):await e().set({[i]:h})},setItems:async i=>{const h=i.reduce((l,{key:d,value:g})=>(l[d]=g,l),{});await e().set(h)},removeItem:async i=>{await e().remove(i)},removeItems:async i=>{await e().remove(i)},clear:async()=>{await e().clear()},snapshot:async()=>await e().get(),restoreSnapshot:async i=>{await e().set(i)},watch(i,h){const l=d=>{const g=d[i];g!=null&&(O(g.newValue,g.oldValue)||h(g.newValue??null,g.oldValue??null))};return e().onChanged.addListener(l),n.add(l),()=>{e().onChanged.removeListener(l),n.delete(l)}},unwatch(){n.forEach(i=>{e().onChanged.removeListener(i)}),n.clear()}}}class Z extends Error{constructor(e,n,i){super(`v${n} migration failed for "${e}"`,i),this.key=e,this.version=n}}const ee=N({main(){console.log("Web Check фоновый скрипт запущен!"),chrome.runtime.onInstalled.addListener(async o=>{o.reason==="install"&&(console.log("Web Check установлен!"),await S.setItem("tasks",[]),await S.setItem("changeCount",0),await S.setItem("settings",{language:"ru-RU",notifications:!0,badgeCounter:!0}))}),chrome.runtime.onMessage.addListener((o,e,n)=>(console.log("Получено сообщение:",o),n({success:!0}),!0))}});function ne(){}(U=(R=globalThis.browser)==null?void 0:R.runtime)!=null&&U.id?globalThis.browser:globalThis.chrome;function q(o,...e){}const te={debug:(...o)=>q(console.debug,...o),log:(...o)=>q(console.log,...o),warn:(...o)=>q(console.warn,...o),error:(...o)=>q(console.error,...o)};let j;try{j=ee.main(),j instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(o){throw te.error("The background crashed on startup!"),o}return j}();
background;
