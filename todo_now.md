# План перехода WebCheck на Offscreen Documents API (Manifest V3)

**Цель**: Заменить текущий механизм создания временных видимых вкладок для проверки изменений на использование скрытых offscreen-документов, чтобы процесс мониторинга стал невидимым для пользователя.

## 1. Подготовительные шаги

- [x] **Обновить `manifest.json`**:
  - [x] Добавить разрешение `"offscreen"` в массив `permissions`.
- [x] **Создать HTML-файл для offscreen-документа**:
  - [x] Создать файл `src/offscreen/offscreen.html`.
  - [x] Подключить в нем скрипт `src/offscreen/offscreen.js`.
- [x] **Создать JavaScript-файл для offscreen-документа**:
  - [x] Создать файл `src/offscreen/offscreen.js`.
- [x] **Настроить сборку**:
  - [x] Убедиться, что `offscreen.html` и `offscreen.js` копируются в директорию `dist/offscreen/` при сборке (обновить `vite.config.js` или ваш скрипт `build.sh`).

## 2. Управление жизненным циклом offscreen-документа

- [ ] **Реализовать менеджер offscreen-документов в Service Worker** (например, в новом файле `src/background/offscreenManager.js` или интегрировать в существующую логику):
  - [ ] Реализовать функцию `hasOffscreenDocument(path)` для проверки существования документа (используя `chrome.runtime.getContexts()`).
  - [ ] Реализовать функцию `ensureOffscreenDocument(path)`:
    - [ ] Проверяет наличие документа с помощью `hasOffscreenDocument`.
    - [ ] Если документа нет, создает его с помощью `chrome.offscreen.createDocument()`.
    - [ ] Использовать подходящую `reason` из `chrome.offscreen.Reason` (например, `USER_INPUT`, так как работа инициируется настройками пользователя, или другая, не накладывающая строгих временных ограничений).
    - [ ] Предусмотреть параметр `justification` для `createDocument`.
    - [ ] Реализовать механизм для предотвращения одновременного создания нескольких документов (например, с использованием промиса `creatingPromise`).

## 3. Модификация логики фонового мониторинга (`src/background/monitor/`)

- [ ] **Интегрировать `ensureOffscreenDocument` в основной модуль мониторинга**:
  - [ ] Вызывать `ensureOffscreenDocument()` перед каждой попыткой проверки URL, требующей DOM-доступа.
- [ ] **Реализовать обмен сообщениями между Service Worker и `offscreen.js`**:
  - [ ] **Service Worker (логика мониторинга)**:
    - [ ] Создать функцию (например, `getContentViaOffscreen(url, selector)`) которая:
      - [ ] Отправляет сообщение в `offscreen.js` с `url` и `selector` (используя `chrome.runtime.sendMessage`). Сообщение должно содержать уникальный идентификатор `target: 'offscreen'` и `type` (например, `PROCESS_URL`).
      - [ ] Ожидает ответ от `offscreen.js` (возвращает Promise).
      - [ ] Внедрить таймаут для ожидания ответа.
      - [ ] Обработать `chrome.runtime.lastError` и ошибки, возвращенные из `offscreen.js`.
  - [ ] **`src/offscreen/offscreen.js`**:
    - [ ] Установить слушатель `chrome.runtime.onMessage.addListener` для приема сообщений от Service Worker.
    - [ ] Проверять `message.target === 'offscreen'` и `message.type`.
- [ ] **Реализовать извлечение контента страницы в `offscreen.js`**:
  - [ ] **Создание и управление `<iframe>`**:
    - [ ] При получении сообщения, динамически создать `<iframe>`.
    - [ ] Установить `src` для `<iframe>` на полученный `url`.
    - [ ] Сделать iframe невидимым (например, `iframe.style.display = 'none'`).
    - [ ] Добавить `<iframe>` в DOM `offscreen.html` (`document.body.appendChild(iframe)`).
    - [ ] Настроить обработчики `iframe.onload` и `iframe.onerror`.
    - [ ] Обязательно удалять `<iframe>` из DOM после завершения работы или при ошибке (`document.body.removeChild(iframe)`).
  - [ ] **Получение контента из `<iframe>` (ключевой этап)**:
    - **Важно**: Прямой доступ к `iframe.contentDocument` из `offscreen.js` будет ограничен для кросс-доменных URL. Необходимо использовать content scripts, которые будут внедряться в этот iframe.
    * [ ] **Настроить Content Script**:
      - [ ] В `manifest.json` объявить content script, который будет внедряться во все фреймы (`"all_frames": true`) и иметь доступ к необходимым URL (`"matches": ["<all_urls>"]` или более специфично).
      - [ ] Этот content script должен уметь:
        - [ ] Получать селектор (например, через сообщение от `offscreen.js` или service worker, если напрямую в offscreen нет `chrome.scripting`).
        - [ ] Извлекать `innerHTML` или другие данные указанного элемента.
        - [ ] Отправлять результат обратно (`chrome.runtime.sendMessage`) в `offscreen.js` или напрямую в service worker.
    * [ ] **Взаимодействие `offscreen.js` с Content Script в `<iframe>`**:
      - [ ] После загрузки `<iframe>` (`iframe.onload`), `offscreen.js` должен инициировать работу content script (например, отправив ему сообщение, если content script его слушает) или просто ожидать сообщение от content script с результатом.
      * _Альтернатива для `offscreen.js`_: если content script настроен на автоматическую работу и отправку сообщения при загрузке в фрейме, `offscreen.js` просто ожидает это сообщение.
  - [ ] **Отправка результата из `offscreen.js` обратно в Service Worker**:
    - [ ] Использовать функцию `sendResponse()` из слушателя `onMessage` для отправки полученных данных (или сообщения об ошибке) обратно в Service Worker.
    - [ ] Не забыть вернуть `true` из слушателя `onMessage` для поддержки асинхронного `sendResponse`.

## 4. Обработка ограничений и повышение надёжности

- [ ] **Реализовать очередь задач в Service Worker**:
  - [ ] Так как одновременно может существовать только один offscreen-документ, задачи по проверке URL должны обрабатываться последовательно, если они требуют DOM-доступа через offscreen-документ.
- [ ] **Усилить обработку ошибок и таймаутов**:
  - [ ] На всех этапах: создание offscreen-документа, отправка/прием сообщений, загрузка `<iframe>`, извлечение контента из `<iframe>`.
- [ ] **Продумать стратегию закрытия offscreen-документа**:
  - [ ] Рассмотреть возможность явного закрытия offscreen-документа (`chrome.offscreen.closeDocument()`) после завершения серии проверок или по таймауту неактивности, чтобы освободить ресурсы. Функция `ensureOffscreenDocument()` будет его пересоздавать по мере необходимости.

## 5. Тестирование и отладка

- [ ] **Провести всестороннее тестирование на различных типах веб-страниц**:
  - [ ] Статические HTML-страницы.
  - [ ] Динамические страницы (одностраничные приложения (SPA), страницы с активным JavaScript-рендерингом).
  - [ ] Страницы с различными Content Security Policy (CSP).
  - [ ] Страницы, требующие авторизации (продумать, как будут обрабатываться cookie и сессии в контексте `<iframe>` внутри offscreen-документа).
- [ ] **Протестировать сценарии ошибок**:
  - [ ] Ошибки загрузки URL в `<iframe>`.
  - [ ] Отслеживаемый элемент не найден на странице.
  - [ ] Превышение таймаутов.
  - [ ] Неожиданное закрытие offscreen-документа браузером.
- [ ] **Активно использовать инструменты разработчика Chrome**:
  - [ ] Для отладки Service Worker (доступ через `chrome://extensions/` -> ваше расширение -> "Service worker").
  - [ ] Для отладки `offscreen.js` (логи можно выводить в консоль Service Worker, или проверять существующие контексты расширения).
  - [ ] Для отладки Content Script, работающего внутри `<iframe>` (через инспектирование фрейма, если это возможно).

## 6. Документация и рефакторинг

- [ ] **Обновить комментарии в коде**, чтобы отразить новую архитектуру и логику работы с offscreen-документами.
- [ ] **Провести рефакторинг существующего кода** в `src/background/monitor/` для чистой интеграции новой системы мониторинга.
- [ ] **Обновить `README.md`** (и другие релевантные документы) для описания изменений в архитектуре и принципах работы фонового мониторинга.
